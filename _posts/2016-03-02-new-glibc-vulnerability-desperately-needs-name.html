---
layout: blogpost
title: "The New glibc Vulnerability that Desperately Needs a Name"
author: "Alise Silde"
author_role: "Security Consultant"
summary: "A lighthearted view on the latest glibc vulnerability and how it compares to similar older issues. 
The GNU C Library, most common in Linux environments, but also widely-used for interfacing with anything that speaks C underneath the hood, already made the InfoSec news in early 2015. This year it has made an impressive comeback, once again causing issues with DNS, but this time affecting a much wider attack surface - potentially the whole Internet."
tags: [Vulnerabilities and exploits]
hero_banner: The_new_glibc_vulnerability_that_desperately_needs_a_name_1010_350_75_s_c1.jpg
---
{% raw %}
<article class="article-content">
<p>Most of the back-end software and infrastructure devices, which we tend to never give a second thought about, use Linux or some exotic manifestation of Unix, depending on the specific task of the node in question. Perhaps we do not give these back-end systems too much thought because they are so reliable, and are supposedly more 'failproof' than your common Windows workstation that can surprise you every other week. Or perhaps it is to avoid a headache.</p>
<p>It also seems to be a common belief that Linux systems are relatively secure, as making anything run on Linux as intended is a lot of effort. Even more effort would have to go into making it run malware, or to developing an exploit which would 'just work' on the unique snowflake Unix environment, lovingly configured by a systems administrator.</p>
<p>Nevertheless, it is these little bespoke wonders – routers, switches, servers, load-balancers, firewalls, DNS servers and other less famous characters – which provide for the "interconnectedness of all things" (Douglas Adams) in the background of their more famous front-end counterparts.</p>
<h2>It all began with a crash</h2>
<p>Unfortunately for everyone who appreciates the numerous benefits of the global network of information and services that we have come to know as the Internet, malicious perpetrators (sometimes still referred to as hackers, because the 90s were not that long ago, no matter what you say) are getting better at what they do in response to technology slowly but surely becoming more secure.</p>
<p>Perhaps one of the first major vulnerabilities that shook the community's belief that Unix is near close to untouchable, was Shellshock – an easy-to-exploit and nearly omnipresent bug in how the Unix Bash shell set and processed environment variables. It allowed attackers to remotely supply their own environment variable values resulting in the target system executing whatever commands they happened to have trailing.</p>
<p>In a way, every vulnerability we find – even if it is 20 years after it was written – is a good thing because we can still learn from it. Most importantly, we can adapt, which is crucial in not letting the attackers have the upper hand. In the case of Shellshock, it certainly got the community thinking and waking up from a false sense of security where it concerns Unix systems. It was inevitable that similar issues would eventually surface.</p>
<p>Once on a long rainy afternoon, a curious Google engineer noticed temperamental behaviour that was unusual even for the SSH service he was debugging. Segmentation faults (segfaults) are not an uncommon problem with low-level machine-to-machine interactions, where high level end-points (including the homo sapiens kind) are involved. However, in years of experience dealing with buffer overflows, reliably occurring segfaults can cause a bit of nervous twitch, especially in the smart guys at Google, who always seem to be paying attention. Another thing about mysterious segfaults – you can bet it is something to do with C.</p>
<p>Turns out it was. Following a long and, as we can only begin to imagine, tedious in-depth investigation of the SSH connection at fault, Google discovered that the ubiquitously used GNU C Library (glibc) was the real culprit in this case.</p>
<h2>Ghost of libc past</h2>
<p>It is not the first time something wrong has been found with glibc. The GHOST vulnerability from early 2015 made a significant amount of noise in its time. Its difficult and limited exploitability, however, never made it quite as famous as Shellshock. In a way it provided a relative level of reassurance that Linux is still a tough cookie to mess with.</p>
<p>Oddly enough, GHOST was also related to hostname resolution via the gethostbyname() functions in glibc, which in retrospect should have led to further investigation of how the library interacts with DNS. But few versions of glibc were affected, and patching was easy; alternatively, users could just opt for using getaddrinfo() instead, which was deemed safe. As a result, the topic did not stir up too much concern and was forgotten rather quickly. However, sometimes ghosts come back to haunt the conscience of the guilty.</p>
<p>When Google discovered the new issue with glibc and DNS, they also found out that it is not even that new. The bug was already reported in July 2015 (hence the weird and slightly misleading CVE number), and the glibc team quietly accepted their fate and worked away at a fix. In addition a couple of researchers at Red Hat also worked away at the issue and exploit development independently. This most certainly sped up resolving the issue at hand (potentially more effectively) now that there seems to be actual interest in it.</p>
<p>It always looks better when you come out with a hot new vulnerability AND a sturdy fix AND plenty of ways it could have been exploited. Google and Red Hat teams also fixed a couple of other issues in glibc while they were at it, such as enhancing the dynamic shared library loader and local storage and fixing a bug in the POSIX realtime support.</p>
<h2>So What?</h2>
<figure class="img-width-2-3">
<div class="modal-img-container">
<picture>
<!--[if IE 9]><video style="display: none;"><![endif]-->
<source media="(min-width: 768px)" srcset="/blog/assets/media/The_internet_box_3m22SGb.width-800_800_476_75_s_c1.jpg"/>
<!--[if IE 9]></video><![endif]-->
<img alt="" srcset="/blog/assets/media/The_internet_box_3m22SGb.width-800_800_476_75_s_c1.jpg"/>
</picture>
<div class="modal-hover">
<a class="modal-img hidden-xs" href="/blog/assets/media/The_internet_box_3m22SGb.width-800_450_268_75.jpg"></a>
<a class="modal-img visible-xs" href="/blog/assets/media/The_internet_box_3m22SGb.width-800_450_268_75.jpg"></a>
</div>
</div><!-- /modal-img-container -->
</figure>
<p>The significance of this bug lies in it affecting nearly all network devices to an extent, and being deeply involved in a process that keeps the Internet going – Domain Name Resolution is serious business. Everyone must have had that time when their DNS went down, and they had to use IP addresses to get to their favourite social networks (obviously before we learned to use Google's DNS or maybe before it was there for us to use).<br/>
<br/>
Something that endangers the very backbone of the Internet is bound to get a lot of attention. Much for the same reason, despite having a fix, it is (a) not that easy to apply because there is downtime involved and (b) impossible to guarantee effective remediation on 'all' of the involved infrastructure. And unfortunately, Linux will just not work without the C library, because as it turns out, machines really like chatting to fellow machines in C, but we would not really want them speaking French.</p>
<p>Additionally consider the special child that the Internet of Things (IoT) has shown itself to be in the past years – none of those smarts work without DNS. Because these interconnected smart devices need to be very lightweight and dependable, a vast majority of them will run on Linux with glibc. Even bespoke embedded systems may turn out to be cleverly disguised Unix. However, there are rumours that Android is unaffected by this flaw - must be all the Java getting in the way. (In reality, Android just does not use glibc.)<br/>
The increasingly popular bitcoin service, no less important than real coin, also uses glibc quite a lot under the hood of it all. Routing money via the Internet may have its dangers, but routing money over a global network vulnerable to remote code execution via domain name routing requests... that just sounds dreadful. Anyway, people are concerned, and for a good reason, it seems.</p>
<p>What is worse, there is extensive research into the possibility that DNS caches could be traversed by a glibc exploit, hence making them susceptible to the same flaw. At the moment it seems like a far stretch and way too much effort. However, the official claim is that this is possible at least in theory. Therefore even hosts behind DNS caches cannot be seen as safe.</p>
<p>The vulnerability affects all versions of glibc since 2.9 (fixed in <a href="https://www.sourceware.org/ml/libc-alpha/2016-02/msg00502.html">2.23</a>). This would span the vast majority of infrastructure services and devices, as well as programming languages and frameworks; PHP, Java, Python, JavaScript and Rails being only some examples. Not surprisingly, even Haskell is not safe. Trust a functional language to have all the reasons in the world to interface via C.</p>
<p>Do not forget to expect the flaw to be present in the unexpected, like the SSH, Sudo (doing things in the name of "root" is not working out well yet again) and Curl utilities. We can only hope that Solitaire does not need to interact with networked hosts via C. But you never 'really' know.</p>
<h2>How it works</h2>
<p>Whenever a machine needs to talk to another machine with which it is not on first name basis, it will ask the DNS for the machine's IP, aka its A (address) record. This will most commonly happen via C's libresolv library, in which case the vulnerability in question (we hope it gets named soon) can come into play.</p>
<p>If an attacker can man-in-the-middle this interaction or otherwise speak when not spoken to, they can reply to the initiator with an overly long (2048+ bytes) A/AAAA record immediately followed by another response that will overwrite the stack. This is because the vulnerable send_dg() and send_vc() functions allocate a whole new buffer if they receive a response larger than the initially expected 2048 bytes.</p>
<p>Once you have a spare buffer on the target system that you can write to, you can supply your own code for the target to execute. Unfortunately, it is never the good kind of code.</p>
<p>Where with GHOST the issue could be solved by using getaddrinfo() instead of gethostbyname(), here getaddrinfo() is the vulnerable method. (There is certainly a lesson here about quick fixes not lasting very long.) When an A/AAAA lookup is initiated, getaddrinfo() calls send_dg() and send_vc(), which are at the bottom of the issue. All of these handy methods and functions reside in the libnss_dns.so.2 NSS module of glibc.</p>
<p>Thank the massive ethical hacking and security research community that buffer overflows have been studied since prehistoric times and we already have mechanisms, such as ASLR, that make exploitation far less trivial than it could have been. The interconnectedness of all things, however, tends to lead to unexpected circumstances. Most things are fairly well protected against buffer overflows, but do these things maybe at some point use some obscure non-memory-safe library? You can bet on it.</p>
<p>You can also bet on Google. They came up with some clever proof of concepts (PoC) to demonstrate bypassing modern buffer overflow mitigations, such as NX and ASLR (and to show off their 1337 skills, no doubt), but for obvious reasons the weaponised exploits will not be made public at least until there is a high degree of certainty that most systems are protected.</p>
<p>The message is clear, however – your fancy stack canaries and randomised memory addresses will be daunting to attackers, but ultimately will not keep you safe.</p>
<p>Enter bad new buffer overflows.</p>
<h2>Recommendations</h2>
<p>First of all, spend some quality time pinpointing the external-facing services that are vulnerable to the issue. The currently released PoC code will merely crash the targeted service or device, which may be up there on the inconvenience scale for live infrastructures, but less so than having hackers roam around in your servers – crashing them is the least bad thing they would do.</p>
<p>You could, of course, go ahead and fix everything you have just in case, but that will involve downtime anyway. That is just something to accept.</p>
<p>Use <a href="https://github.com/fjserna/CVE-2015-7547">this</a>. From there on it should be easy to tell that your system is vulnerable - it crashed.</p>
<p>It may look something like this:</p>
<pre class="prettyprint">(gdb) x/i $rip
=&gt; 0x7fe156f0ccce &lt;_nss_dns_gethostbyname4_r+398&gt;: req
(gdb) x/a $rsp
0x7fff56fd8a48: 0x4242424242424242 0x4242424242420042</pre>
<p>The best option from here is to upgrade to the fixed version of glibc (2.23). Red Hat customers are in luck, because they also get very helpful instructions on how to achieve this.</p>
<p>If restarting to update all packages really is a problem, you can try listing all running processes that use an old version of glibc. Use the following command:</p>
<pre class="prettyprint">lsof +c0 -d DEL | awk 'NR==1 || /libc-/ {print $2,$1,$4,$NF}' | column -t</pre>
<p>You should then be able to restart these separately, without disrupting the rest of the system.</p>
<p>If you cannot fix it, because it is too much work, and/or you cannot afford the downtime, you can still fortify and hope for the best. Or reconfigure the local DNS for external-facing services to limit the accepted response sizes. The heroes of this story, Google and Red Hat, recommend tools such as DNSMasq.</p>
<p>Given how long it has been from discovering the vulnerability to supplying a fix – the vulnerability has been laying low since last July – it is not unreasonable to suspect the flaw has already been exploited by non-well-meaning individuals. Therefore a health check and a run through the logs may be a good idea if your infrastructure handles security sensitive or otherwise profitable content.</p>
<p>'Mitigations' that do not work:</p>
<ul>
<li>Setting `options single-request` does not change buffer management and does not prevent the exploit.</li>
<li>Setting `options single-request-reopen` does not change buffer management and does not prevent the exploit.</li>
<li>Disabling IPv6 does not disable AAAA queries. The use of AF_UNSPEC unconditionally enables the dual query.</li>
<li>The use of `sysctl -w net.ipv6.conf.all.disable_ipv6=1` will not protect your system from the exploit.</li>
<li>Blocking IPv6 at a local or intermediate resolver does not work to prevent the exploit. The exploit payload can be delivered in A or AAAA results, it is the parallel query that triggers the buffer management flaw.</li>
</ul>
<p>(Carlos O'Donell, Red Hat)</p>
<p>Remember - by going through the trouble of securing your systems, you are helping save the Internet (and maybe even make Google reveal their amazing weaponised exploits). </p>
<p>Happy fixing!</p>
<h2>Contact and Follow-Up</h2>
<p>Alise is part of our Assurance team in our London office. See the <a href="https://www.contextis.com/en/contact">Contact</a> page for how to get in touch. She's an IT professional (with a talent to break things and then have to fix them), security enthusiast, sometimes a serious person.</p>
<h2>References</h2>
<ol>
<li><a href="https://googleonlinesecurity.blogspot.co.uk/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">Google's Disclosure Blog</a></li>
<li><a href="https://access.redhat.com/errata/RHSA-2016:0175">Red Hat Security Advisory</a> </li>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=18665">The Bug Report</a></li>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7547">The CVE</a></li>
<li><a href="https://access.redhat.com/security/vulnerabilities/2168451">The CVE by Red Hat</a></li>
<li><a href="https://github.com/fjserna/CVE-2015-7547">Proof of Concept</a></li>
<li><a href="https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html">The Patch</a></li>
<li><a href="http://dankaminsky.com/2016/02/20/skeleton/">Dan Kaminsky on DNS Cache Attacks</a></li>
<li><a href="https://www.cert.gov.uk/resources/alerts/update-bash-vulnerability-aka-shellshock/">Shellshock</a></li>
<li><a href="https://www.theregister.co.uk/2014/09/24/bash_shell_vuln/">Shellshock in The News</a></li>
<li><a href="https://isc.sans.edu/forums/diary/New+Critical+GLibc+Vulnerability+CVE20150235+aka+GHOST/19237/">GHOST</a></li>
<li><a href="https://www.gnu.org/software/libc/">The GNU C Library</a></li>
<li><a href="https://access.redhat.com/articles/11258">Red Hat Enterprise Guide to Patching</a></li>
<li><a href="https://tools.ietf.org/html/rfc6147">RFC6147 DNS64</a></li>
</ol>
<p>Other Comments on the Issue:</p>
<ol>
<li><a href="https://arstechnica.com/security/2016/02/extremely-severe-bug-leaves-dizzying-number-of-apps-and-devices-vulnerable/">Ars Technica</a></li>
<li><a href="https://gfragkos.blogspot.co.uk/2016/02/critical-vulnerability-found-in-glibc.html">Grigorios Fragkos</a></li>
<li><a href="https://linux.slashdot.org/story/16/02/16/1724222/red-hat-google-disclose-severe-glibc-dns-vulnerability-patched-but-widespread">SlashDot</a></li>
</ol>
</article>
{% endraw %}