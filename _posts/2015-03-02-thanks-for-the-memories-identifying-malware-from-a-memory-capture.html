---
layout: blogpost
title: "Thanks for the Memories: Identifying Malware from a Memory Capture"
author: "Adam Bridge"
author_role: "Head of Response"
summary: "We've all seen attackers try and disguise their running malware as something legitimate. They might use a file name of a legitimate Windows file or even inject code into a legitimate process that's already running. Regardless of how it's done, that code has to run, which means it has to be in memory. Somewhere."
tags: [Vulnerabilities and exploits]
hero_banner: Thanks_for_the_memories_identifying_malware_from_a_memory_capture_1010_350_75_s_c1.jpg
---
{% raw %}
<article class="article-content">
<p>In this blog post we lay out a real-life examination of computer memory which enabled us to identify a keylogger that was running, what files were responsible for running it, and how it managed to ensure it was started every time the machine booted up. Not only did this provide us with previously unknown indicators of compromise, but also specific details with which we could assist the client in their remediation efforts.</p>
<h2>Background</h2>
<p>During some hard disk forensics, one of our examiners found a text file which was clearly a log of a keylogger application. I won't share the gory details of what it contained - I'm sure you can imagine. By performing a search for the file name, the examiner found a hit in C:\Windows\MEMORY.DMP. This file stores debug information when a system failure occurs. The examiner passed this one over to me to see if I could do anything to help identify the keylogger.</p>
<p>I've anonymised the username for the purposes of this blog, replacing the username of the currently logged in user with 'theuser', but the file we're interested in is:</p>
<pre class="prettyprint">C:\Users\theuser\AppData\Local\Temp\theuser_tmp.dat</pre>
<p>As is probably obvious, the file name is made up of logged-in-user-name + _tmp.dat.</p>
<p>In this case, as is the default, Windows had created a '<a href="http://blogs.technet.com/b/askperf/archive/2008/01/08/understanding-crash-dump-files.aspx">Kernel Memory Dump</a>'. That is, not a full memory dump, but enough to help troubleshoot system failures. Unfortunately, at least to the best of my knowledge, there's not too much that can be done with a Kernel Memory Dump. However, that didn't deter us. The hard disk also contained a <a href="http://www.forensicswiki.org/wiki/Hiberfil.sys">hiberfil.sys</a>, which is the file that Windows uses when it goes into hibernation; it essentially contains a copy of RAM at the time the machine enters the hibernation state.</p>
<h2>Enter Volatility</h2>
<p>There are a few memory forensics tools out there, but the one I've seen prove itself time and time again is <a href="https://github.com/volatilityfoundation/volatility">Volatility</a> from the <a href="http://www.volatilityfoundation.org/">Volatility Foundation</a>. Volatility is written in python, is free and is open source.</p>
<p>Armed with the latest version of Volatility (2.4, at the time of writing), I set about examining the hiberfil.sys. The first hurdle was compression - hiberfil.sys files are compressed, so Volatility has to decompress the file on the fly in order to analyse it. This is slow. Luckily, Volatility provides the <a href="http://code.google.com/p/volatility/wiki/CommandReference23#imagecopy">imagecopy</a> plugin which allows us to convert one type of memory dump (e.g. hiberfil) into a raw, uncompressed format - much faster.</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.sys --profile=Win7SP1x64 imagecopy -O hiberfil.dd</pre>
<h2>Is the file into which the keystrokes are being logged actually referenced in memory?</h2>
<p>With an uncompressed image, and contemporaneous notes underway, a good starting point was to see if the file was open in memory. For that, we use <a href="http://code.google.com/p/volatility/wiki/CommandReference23#filescan">filescan</a>:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 filescan</pre>
<p>And in the output, we look for our file:</p>
<pre class="prettyprint">Offset(P)  Pointers Handles Access Name
---------- -------- ------- ------ ----
--SNIP--
0x1b66ef20 16       0       -W--w- \Device\HarddiskVolume1\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
--SNIP--</pre>
<p>This is good news. The file was indeed open, for write access, when the memory dump was taken. At least we know we're not wasting our time.</p>
<h2>Which processes are accessing the file?</h2>
<p>The next step was to see which processes were accessing the file. A <a href="http://computer.forensikblog.de/en/2009/04/linking-file-objects-to-processes.html">useful blog post from Andreas Schuster</a> says that Volatility should be able to resolve the process(es) by following the <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff545834(v=vs.85).aspx">_FILE_OBJECT</a> structure. However, the blog post relates to quite an old version of Volatility and it doesn't seem to apply to the current version. Or it might be that it only works with handles, which in this case we didn't have. Regardless, there's always something else to try.</p>
<p>By using <a href="http://technet.microsoft.com/en-gb/sysinternals/bb897439.aspx">strings from Sysinternals</a> we can find the positions (offsets) within the raw memory dump where the paths can be seen, and save them to a file:</p>
<pre class="prettyprint">C:\&gt;strings -o -n 9 hiberfil.dd | findstr /I /L "\theuser_tmp.dat" &gt;strings.txt</pre>
<p>And the output, in strings.txt, looks something like this:</p>
<pre class="prettyprint">--SNIP--
785366187:\Device\HarddiskVolume1\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
795296032:\Device\HarddiskVolume1\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
821237504:C:\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
829851904:C:\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
--SNIP--</pre>
<p>We can then use this strings file as an input to Volatility's strings plugin. The strings plugin takes a text file where each line contains a decimal offset and string to find, for example: 123456:some_text, and returns the process ID and virtual address where the string is found.</p>
<p>So:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 strings -s strings.txt &gt;strings-output.txt</pre>
<p>Gives us the following in strings-output.txt:</p>
<pre class="prettyprint">--SNIP--
1125860523 [2000:008d74ab] \Device\HarddiskVolume1\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
1160780915 [4628:1051ec73] c:\users\theuser\appdata\local\temp\theuser_tmp.dat
1167748112 [kernel:fa8001c4ec10] heuser\AppData\Local\Temp\theuser_tmp.dat:6E53BFF5-0001-412B-8407-E3AEDE763511:$DATA
1336598656 [kernel:f8a007b1b080] \Users\theuser\AppData\Local\Temp\theuser_tmp.dat
1542979888 [4628:0322d130] C:\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
1575054952 [3056:025c3e68] \Device\HarddiskVolume1\Users\theuser\AppData\Local\Temp\theuser_tmp.dat
--SNIP--</pre>
<p>By working through the file, a unique list of processes accessing the strings can be drawn up:</p>
<ul>
<li>kernel</li>
<li>2000</li>
<li>3056</li>
<li>4628</li>
</ul>
<p>The process IDs can be easily found by running the <a href="https://code.google.com/p/volatility/wiki/CommandReference23#pslist">pslist</a> plugin and checking the PID value:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 pslist</pre>
<p>The output gives us:</p>
<pre class="prettyprint">Offset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit
------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------
0xfffffa8001719b30 System                    4      0    146     2056 ------      0 2014-09-15 07:35:03 UTC+0000
0xfffffa800305d040 smss.exe                320      4      2       33 ------      0 2014-09-15 07:35:03 UTC+0000
0xfffffa8004eeeb30 csrss.exe               456    448     10     1052      0      0 2014-09-15 07:35:10 UTC+0000
--SNIP--
0xfffffa800639cb30 Rtvscan.exe            3056    612     24      531      0      1 2014-09-15 07:35:34 UTC+0000
--SNIP--
0xfffffa8002d63490 ccSvcHst.exe           2000    612     36      408      0      1 2014-09-15 07:35:28 UTC+0000
--SNIP--
0xfffffa80032a0b30 svchost.exe            2816    612     4       102      0      0 2014-09-15 07:35:33 UTC+0000
--SNIP--
0xfffffa8003a766f0 explorer.exe           4628   4460     46     1118      1      0 2014-09-15 07:36:12 UTC+0000
--SNIP--</pre>
<p>So, kernel, ccSvcHst, Rtvscan and explorer all have references to the file path in their process memory space.</p>
<p>ccSvcHst and Rtvscan are both components of the Symantec endpoint protection software installed on the system. It's reasonable that the AV would be listing the file for a variety of reasons, but explorer is slightly odd. Explorer is spawned when one uses an open or save file dialog, but that seems unlikely for a malicious file. The explorer process definitely warrants a closer look.</p>
<h2>A closer look at explorer.exe</h2>
<p>Checking the md5 of explorer.exe we can be happy that explorer itself hasn't been tampered with. Perhaps a DLL is being injected. Of course, Volatility provides a plugin with which we can check what DLLs a process has loaded; the appropriately named <a href="https://code.google.com/p/volatility/wiki/CommandReference#dlllist">dlllist</a>.</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 dlllist --pid=4628</pre>
<pre class="prettyprint">************************************************************************
explorer.exe pid:   4628
Command line : C:\Windows\Explorer.EXE
Service Pack 1

Base                             Size          LoadCount Path
------------------ ------------------ ------------------ ----
0x00000000ffe90000           0x2c0000             0xffff C:\Windows\Explorer.EXE
0x00000000777b0000           0x1a9000             0xffff C:\Windows\SYSTEM32\ntdll.dll
0x0000000077690000           0x11f000             0xffff C:\Windows\system32\kernel32.dll
0x000007fefd900000            0x6b000             0xffff C:\Windows\system32\KERNELBASE.dll
--SNIP--
0x000007fef5930000            0x15000                0x1 C:\Windows\Installer\WinInstall.dll
--SNIP--</pre>
<p>There were actually 215 DLLs loaded by explorer. (In case you're thinking 215 sounds suspiciously high, it's not. If you've got 'Process Explorer' to hand, check your own explorer.exe - I bet you've got around 200 loaded.)</p>
<p>So, scrolling down the list preparing myself to have to check the md5 of each, I noticed the one between the snips above: C:\Windows\Installer\WinInstall.dll. This folder is immediately suspicious: there aren't normally DLLs in the root of the Installer folder.</p>
<p>The easy option here would be to fire up the hard disk image and take a look at the file, but:</p>
<ol>
<li>we're showing off memory skills here, and</li>
<li>I don't have the hard disk drive image.</li>
</ol>
<p>But that's fine, because Volatility also includes a <a href="https://code.google.com/p/volatility/wiki/CommandReference#dlldump">dlldump</a> plugin. No prizes for guessing that it dumps DLLs.</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 dlldump --pid=4628 --dump-dir=4628</pre>
<pre class="prettyprint">Process(V)         Name                 Module Base        Module Name          Result
------------------ -------------------- ------------------ -------------------- ------
0xfffffa8003a766f0 explorer.exe         0x00000000ffe90000 Explorer.EXE         OK: module.4628.74a766f0.ffe90000.dll
0xfffffa8003a766f0 explorer.exe         0x00000000777b0000 ntdll.dll            OK: module.4628.74a766f0.777b0000.dll
0xfffffa8003a766f0 explorer.exe         0x0000000002130000 apphelp.dll          OK: module.4628.74a766f0.2130000.dll
0xfffffa8003a766f0 explorer.exe         0x0000000180000000 igfxpph.dll          OK: module.4628.74a766f0.180000000.dll
--SNIP--
0xfffffa8003a766f0 explorer.exe         0x000007fef5930000 WinInstall.dll       OK: module.4628.74a766f0.7fef5930000.dll
--SNIP--</pre>
<p>This article isn't the place to get into the analysis of the DLL, but if we do strings against the file we get some pretty damning clues...</p>
<pre class="prettyprint">--SNIP--
[Right SHIFT]
[Left SHIFT]
[SCROLL LOCK]
[NUM LOCK]
[F12]
[F11]
[F10]
--SNIP--
Global\Klogger
--SNIP--
[d/d/%d d:d:d] (%s)
RegisterRawInputDevices
User32.dll
GetRawInputData
user32.dll
%s\%s_tmp.dat
KLogger
--SNIP--
E:\Code\Keylog\KloggerDll\x64\Release\KloggerDll.pdb
--SNIP--</pre>
<p>It's easy enough to see:</p>
<ul>
<li>Keylogger key mappings, e.g. the right shift key becomes [Right SHIFT]</li>
<li>A timestamp and message format string: [d/d/%d d:d:d] (%s)</li>
<li>The name of two Windows API functions to do with getting raw input.</li>
<li>A format string for our file name: %s\%s_tmp.dat</li>
<li>And generally, terms to do with 'logger'.</li>
</ul>
<h2>How is the DLL injected into explorer?</h2>
<p>All that's left for us to do now is to see how the DLL is being injected into the explorer process.</p>
<p>I fully expected this to be a key/value pair in the Registry, so because we're staying in memory, let's use Volatility's <a href="https://github.com/volatilityfoundation/volatility/blob/master/volatility/plugins/registry/dumpregistry.py">dumpregistry</a> plugin to, well, dump the Registry files from memory to disk:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 dumpregistry --dump-dir=reg</pre>
<p>We end up with a file listing like this:</p>
<pre class="prettyprint">Volume in drive C has no label.
 Volume Serial Number is 1234-5678

 Directory of C:\reg

14/01/2015  09:21    &lt;DIR&gt;          .
14/01/2015  09:21    &lt;DIR&gt;          ..
23/12/2014  12:10             8,192 registry.0xfffff8a00000f010.no_name.reg
23/12/2014  13:57        22,675,456 registry.0xfffff8a000023290.SYSTEM.reg
23/12/2014  12:10           282,624 registry.0xfffff8a00006b410.HARDWARE.reg
23/12/2014  12:10        66,224,128 registry.0xfffff8a001bf7410.SOFTWARE.reg
23/12/2014  12:10            40,960 registry.0xfffff8a004071010.SECURITY.reg
23/12/2014  12:10            36,864 registry.0xfffff8a0040dc410.SAM.reg
23/12/2014  12:10           245,760 registry.0xfffff8a004153410.NTUSERDAT.reg
23/12/2014  12:10           249,856 registry.0xfffff8a00431d410.NTUSERDAT.reg
23/12/2014  12:10         4,128,768 registry.0xfffff8a004ef8010.ntuserdat.reg
23/12/2014  12:10         6,733,824 registry.0xfffff8a005405010.UsrClassdat.reg
23/12/2014  12:10         5,808,128 registry.0xfffff8a00712f010.Syscachehve.reg
23/12/2014  12:10           286,720 registry.0xfffff8a007c9f010.DEFAULT.reg
              12 File(s)    106,721,280 bytes
               2 Dir(s)  69,660,389,376 bytes free</pre>
<p>Next step, lets see if we can quickly identify which of these files contains a reference to WinInstall.dll:</p>
<pre class="prettyprint">C:\&gt;strings.exe reg\*.reg | findstr /I /L WinInstall.dll</pre>
<pre class="prettyprint">FINDSTR: Line 662056 is too long.</pre>
<p>So one line is too long, that's normal, but there are no results. That is unexpected.</p>
<p>What about the folder in which the file resides:</p>
<pre class="prettyprint">C:\&gt;strings.exe reg\*.reg | findstr /R C:\\Windows\\Installer\\.*dll</pre>
<pre class="prettyprint">C:\reg\registry.0xfffff8a000023290.SYSTEM.reg: C:\Windows\Installer\adspack.dll
C:\reg\registry.0xfffff8a000023290.SYSTEM.reg: C:\Windows\Installer\adspack.dll
FINDSTR: Line 662056 is too long.</pre>
<p>So now we have a SECOND DLL in the C:\Windows\Installer folder?! That's suspicious. Is THAT dll loaded by any processes?</p>
<p>Let's see if 'adspack.dll' appears anywhere.</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 dlllist &gt;dlllist_all.txt</pre>
<pre class="prettyprint">--SNIP--
************************************************************************
svchost.exe pid:   2816
Command line : C:\Windows\system32\svchost.exe -k netsvcs
Service Pack 1

Base                             Size          LoadCount Path
------------------ ------------------ ------------------ ----
0x00000000ffdb0000             0xb000             0xffff C:\Windows\system32\svchost.exe
0x00000000777b0000           0x1a9000             0xffff C:\Windows\SYSTEM32\ntdll.dll
0x0000000077690000           0x11f000             0xffff C:\Windows\system32\kernel32.dll
--SNIP--
0x000007fef85e0000            0x25000                0x1 c:\windows\installer\adspack.dll
--SNIP--</pre>
<p>Our mystery dll is loaded by svchost - a service?</p>
<p>Let's grab a copy of this file:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 dlldump --pid=2816 --dump-dir=2816
Process(V)         Name                 Module Base        Module Name          Result
------------------ -------------------- ------------------ -------------------- ------
0xfffffa80032a0b30 svchost.exe          0x00000000ffdb0000 svchost.exe          OK: module.2816.752a0b30.ffdb0000.dll
0xfffffa80032a0b30 svchost.exe          0x00000000777b0000 ntdll.dll            OK: module.2816.752a0b30.777b0000.dll
--SNIP--
0xfffffa80032a0b30 svchost.exe          0x000007fef85e0000 adspack.dll          OK: module.2816.752a0b30.7fef85e0000.dll
--SNIP--</pre>
<p>And take a look at it in <a href="http://www.mitec.cz/exe.html">MiTeC's EXE Explorer</a>.</p>
<p>A 'ServiceMain' function is exported...</p>
<figure class="img-width-2-3">
<div class="modal-img-container">
<picture>
<!--[if IE 9]><video style="display: none;"><![endif]-->
<source media="(min-width: 768px)" srcset="/blog/assets/media/bridge_nfto_mitec_dll_1.focus-none.width-800_800_130_s_c1.png"/>
<!--[if IE 9]></video><![endif]-->
<img alt="" srcset="/blog/assets/media/bridge_nfto_mitec_dll_1.focus-none.width-800_800_130_s_c1.png"/>
</picture>
<div class="modal-hover">
<a class="modal-img hidden-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/bridge_nfto_mitec_dll_1.focus-none.width-800.png"></a>
<a class="modal-img visible-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/bridge_nfto_mitec_dll_1.focus-none.width-800.png"></a>
</div>
</div><!-- /modal-img-container -->
</figure>
<p>...and there's a resource called 'DLL', which IS WinInstall.dll:</p>
<figure class="img-width-2-3">
<div class="modal-img-container">
<picture>
<!--[if IE 9]><video style="display: none;"><![endif]-->
<source media="(min-width: 768px)" srcset="/blog/assets/media/bridge_nfto_mitec_dll_2.focus-none.width-800_800_385_s_c1.png"/>
<!--[if IE 9]></video><![endif]-->
<img alt="" srcset="/blog/assets/media/bridge_nfto_mitec_dll_2.focus-none.width-800_800_385_s_c1.png"/>
</picture>
<div class="modal-hover">
<a class="modal-img hidden-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/bridge_nfto_mitec_dll_2.focus-none.width-800.png"></a>
<a class="modal-img visible-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/bridge_nfto_mitec_dll_2.focus-none.width-800.png"></a>
</div>
</div><!-- /modal-img-container -->
</figure>
<p>Analysis of this DLL shows that it runs as a service, drops WinInstall.dll and injects it into explorer.</p>
<p>We already know from above that this DLL is referenced in the SYSTEM hive, so it's a quick check (with <a href="http://www.mitec.cz/wrr.html">MiTeC's Windows Registry Recovery</a>) to see precisely where:</p>
<figure class="img-width-2-3">
<div class="modal-img-container">
<picture>
<!--[if IE 9]><video style="display: none;"><![endif]-->
<source media="(min-width: 768px)" srcset="/web/20210412135031im_/https://www.contextis.com/media/images/content/reg_adspack.focus-none.width-800.png"/>
<!--[if IE 9]></video><![endif]-->
<img alt="" srcset="/web/20210412135031im_/https://www.contextis.com/media/images/content/reg_adspack.focus-none.width-800.png"/>
</picture>
<div class="modal-hover">
<a class="modal-img hidden-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/reg_adspack.focus-none.width-800.png"></a>
<a class="modal-img visible-xs" href="/web/20210412135031/https://www.contextis.com/media/images/content/reg_adspack.focus-none.width-800.png"></a>
</div>
</div><!-- /modal-img-container -->
</figure>
<p>So, as we can see, a service called Ias is started at boot using adspack.dll.</p>
<h2>Bullet-Point Summary</h2>
<ul>
<li>On start-up, a service called 'Ias' is started the binary for which is C:\Windows\Installer\adspack.dll.</li>
<li>This dll drops another dll, C:\Windows\Installer\WinInstall.dll, which is a keylogger.</li>
<li>This keylogger is injected into the explorer.exe process.</li>
</ul>
<h2>Contact and Follow-up</h2>
<p>Adam is part of our Response team in Context's Cheltenham office. See the Contact page for how to get in touch.</p>
<h2>Appendix: Get Lucky! A keylogger has to log key strokes.</h2>
<p>As we're hunting a keylogger, we can consider something a keylogger has to do: log keystrokes that can't be represented by a printable character. For example: backspace, enter, home, end, etc. Often, as was the case in this instance, keyloggers represent these unprintable characters as the literal name within square brackets, for example: [ENTER]. We could have looked for that with strings again:</p>
<pre class="prettyprint">C:\&gt;strings -o -n 11 hiberfil.dd | findstr /I /L "[BACKSPACE]" &gt;backspace.txt</pre>
<p>Which gives an output of:</p>
<pre class="prettyprint">834782000:[BACKSPACE]
1165946328:[BACKSPACE]</pre>
<p>OK! So, we have a couple of matches. Back to our strings plugin:</p>
<pre class="prettyprint">C:\&gt;python vol.py -f hiberfil.dd --profile=Win7SP1x64 strings -s backspace.txt	
834782000 [4628:7fef593b330] [BACKSPACE]
1165946328 [2816:7fef85fcdd8][BACKSPACE]</pre>
<p>Nice! So, we have two processes that contain the string:</p>
<ul>
<li>2816 svchost.exe</li>
<li>4628 explorer.exe</li>
</ul>
<p>So, explorer.exe has hit again, and svchost.exe is of course the process responsible for launching services. This would have identified our two processes too, but those unprintable characters could've been encoded in any kind of way - looks like our attackers were just a little lazy.</p>
</article>
{% endraw %}